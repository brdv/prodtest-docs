"use strict";(self.webpackChunkprodtest=self.webpackChunkprodtest||[]).push([[932],{3905:(e,t,a)=>{a.d(t,{Zo:()=>u,kt:()=>p});var r=a(7294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},o=Object.keys(e);for(r=0;r<o.length;r++)a=o[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)a=o[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var l=r.createContext({}),c=function(e){var t=r.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},u=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=c(a),p=n,m=d["".concat(l,".").concat(p)]||d[p]||h[p]||o;return a?r.createElement(m,i(i({ref:t},u),{},{components:a})):r.createElement(m,i({ref:t},u))}));function p(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=a.length,i=new Array(o);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:n,i[1]=s;for(var c=2;c<o;c++)i[c]=a[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,a)}d.displayName="MDXCreateElement"},8370:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var r=a(7462),n=(a(7294),a(3905));const o={title:"Dark Launch",sidebar_position:1},i="Dark launch",s={unversionedId:"tip-basics/dark-launch/dark-launch",id:"tip-basics/dark-launch/dark-launch",title:"Dark Launch",description:"This page describes a dark launch, also known as shadow release, dark mirror release or dark traffic test but at prodtest we call it a dark launch. A dark launch is a deployment or testing strategy for testing a newer version of a service or piece of software. The main goal of a dark launch is to mirror (a subset of) incoming production traffic to the new service but discarding the response. This allows you to monitor the functionality and performance of the service while under a real-world production load without taking the risk of exposing your users to it.",source:"@site/docs/tip-basics/dark-launch/dark-launch.md",sourceDirName:"tip-basics/dark-launch",slug:"/tip-basics/dark-launch/",permalink:"/prodtest-docs/tip-basics/dark-launch/",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Dark Launch",sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Testing in production",permalink:"/prodtest-docs/category/testing-in-production"},next:{title:"Data Separation",permalink:"/prodtest-docs/tip-basics/dark-launch/data-separation"}},l={},c=[{value:"What is a dark launch",id:"what-is-a-dark-launch",level:2},{value:"Why use a dark launch",id:"why-use-a-dark-launch",level:2},{value:"How to dark launch",id:"how-to-dark-launch",level:2},{value:"External",id:"external",level:3},{value:"Internal",id:"internal",level:3},{value:"Risks of dark launch",id:"risks-of-dark-launch",level:2},{value:"Data separation",id:"data-separation",level:3},{value:"Example of a dark launch",id:"example-of-a-dark-launch",level:2}],u={toc:c};function h(e){let{components:t,...o}=e;return(0,n.kt)("wrapper",(0,r.Z)({},u,o,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"dark-launch"},"Dark launch"),(0,n.kt)("p",null,"This page describes a dark launch, also known as shadow release, dark mirror release or dark traffic test but at prodtest we call it a dark launch. A dark launch is a deployment or testing strategy for testing a newer version of a service or piece of software. The main goal of a dark launch is to mirror (a subset of) incoming production traffic to the new service but discarding the response. This allows you to monitor the functionality and performance of the service while under a real-world production load without taking the risk of exposing your users to it."),(0,n.kt)("p",null,"This guide describes dark launches more in depth and shows various ways to implement a dark launch."),(0,n.kt)("h2",{id:"what-is-a-dark-launch"},"What is a dark launch"),(0,n.kt)("p",null,"As mentioned in the top section, a dark launch means that you will deploy two versions of the same service or software. Let's call them Vcurrent (released version) and Vnext (new version). When both versions are deployed you have to mirror (a part of) the incoming requests to Vnext. Mirroring means that somehow (we'll get to that later) you have to send requests to both Vcurrent and Vnext - the mirroring - while letting the user interact solely with Vcurrent. The traffic that is mirrored to Vnext will not result in a response to the user. The basic interaction will look like this:"),(0,n.kt)("p",null,(0,n.kt)("img",{alt:"Dark Launch basic",src:a(9962).Z,width:"695",height:"376"})),(0,n.kt)("p",null,"Note that a more elaborate scheme is depicted in ",(0,n.kt)("a",{parentName:"p",href:"#how-to-dark-launch"},"How to dark launch"),"."),(0,n.kt)("h2",{id:"why-use-a-dark-launch"},"Why use a dark launch"),(0,n.kt)("p",null,"Let's say that you have upgraded an important piece of a service that has to do with an expected response time improvement. You want to test the service to see if the expected speed improvement will actually occur. Because you don't know if the improvement is stable yet, you want to test the service without exposing it to end-users. By implementing a dark launch you can directly test your new service with actual real-world production traffic that is generated by users. Since the response from Vnext is discarded, the end-user will not know about the processing that happens in Vnext."),(0,n.kt)("h2",{id:"how-to-dark-launch"},"How to dark launch"),(0,n.kt)("p",null,"There are two main ways to do a dark launch, external and internal, both with their own use case."),(0,n.kt)("p",null,"The first use case is to dark launch a new (version of) a service that receives requests from outside your infrastructure (e.g. cluster). This is called an external dark launch. In this case you receive a request from an external service or client. You can copy the request at the entrypoint to your infrastructure. Usually, this entrypoint is a proxy service. The idea is that you add a rule to the proxy to - besides sending all requests to Vcur - copy a certain percentage to the Vnext instance. The proxy should then discard the responses from Vnext and only return the response from Vcur."),(0,n.kt)("p",null,"There are several proxies that support mirroring incoming requests, ",(0,n.kt)("a",{parentName:"p",href:"https://nginx.org/en/docs/http/ngx_http_mirror_module.html"},"NGINX")," and ",(0,n.kt)("a",{parentName:"p",href:"https://doc.traefik.io/traefik/routing/services/#mirroring-service"},"Traefik")," are two examples. In the demo project, an example using Traefik has been implemented. (",(0,n.kt)("a",{parentName:"p",href:"/demo/examples/external-dl"},"Check it out!"),")"),(0,n.kt)("p",null,"The second type of dark launches is a use case where the requests originates from within your infrastructure. The request originates from a service A and goes to service B. Since this all happens within your infrastructure, this type of dark launch is called an internal dark launch. There are several ways to implement an internal dark launch. ",(0,n.kt)("strong",{parentName:"p"},(0,n.kt)("em",{parentName:"strong"},"This use case will be explored in a later iteration."))),(0,n.kt)("p",null,"Which option is best suited for you, depends on your use case. Basically it depends of the architecture and the origin of the request you will use. If you want to dark launch something that receives requests through a proxy, take advantage of that proxy. An example implementation can be ",(0,n.kt)("a",{parentName:"p",href:"/demo/examples/external-dl"},"found here"),".\nIf your use case consists of communication within a cluster between two services, a proxy implementation of a dark launch might not suffice. In that case, look into other options as ",(0,n.kt)("a",{parentName:"p",href:"#"},"described here"),"."),(0,n.kt)("h3",{id:"external"},"External"),(0,n.kt)("p",null,"As described above, an external dark launch can benefit the use of a proxy.\nA proxy - or proxyserver - is a server application that sits in between a client and a resource and that acts as an intermediary. The benefits of a proxy is that the client does not have to have a direct connection to the resource but can request a resource by the proxy. The proxy in turn passes the request to the resource and returns the response. This intermediary can allow you to make a copy of (a percentage of) all incoming requests and send that copy to a newer version of the resource. Both resources can log relevant information that in turn can be sent to a monitoring service. This would look as follows:"),(0,n.kt)("p",null,(0,n.kt)("img",{alt:"Dark Launch proxy concept",src:a(2785).Z,width:"877",height:"299"})),(0,n.kt)("p",null,"*"," the response of Vnext will be discarded by the proxy. Only the response of Vcurrent will be sent back."),(0,n.kt)("h3",{id:"internal"},"Internal"),(0,n.kt)("p",null,"When you want to dark launch a new service that communicates directly with another service in your cluster, you can use an internal dark launch. Internal meaning that the communication happens within your cluster."),(0,n.kt)("p",null,"An internal dark launch can be implemented by using a message queue (often in combination with an Event-Driven Architecture, EDA). In this case you have a service (service A), that uses another service (service B) for your application. Normally, service A publishes an event to a message queue, which will be consumed by the subscriber, i.e. service B. You want to test how a new version of service B would handle real-world production data and decide to implement a dark launch."),(0,n.kt)("p",null,"This would go as follows: setup your message queue to allow multiple consumers for an event. Let both service B vlatest and vnext consume those events and do their work. Eventually, both versions will return an event to the queue. The response of Vnext is flagged in some way (for example: with an origin = vnext property) telling service A to ignore this response. Below you can see a schematic view of this use case:"),(0,n.kt)("p",null,(0,n.kt)("img",{alt:"internal dark launch simple",src:a(3381).Z,width:"786",height:"299"})),(0,n.kt)("p",null,"As you can see, service A only consumes responses (acknowledgement) of the Vlatest service."),(0,n.kt)("h2",{id:"risks-of-dark-launch"},"Risks of dark launch"),(0,n.kt)("p",null,"Since the goal of a dark launch is to test a new or updated service in a production environment under production load ",(0,n.kt)("strong",{parentName:"p"},"without")," exposing it to end users, the risks of a dark launch are relatively small. However there are a few things to keep in mind when implementing a dark launch."),(0,n.kt)("h3",{id:"data-separation"},"Data separation"),(0,n.kt)("p",null,"Since you are testing a new feature in a production environment using production data (from the mirrored requests), you have to be very careful nog to save the responses from the new feature or service to the production database that ",(0,n.kt)("strong",{parentName:"p"},"is")," exposed to end users. There are different ways an application can collect and store data. For example in a database or on a message queue. The ",(0,n.kt)("a",{parentName:"p",href:"/prodtest-docs/demo/technical-detail/data-separation"},"technical details")," section of this website describes the ways to separate the data generated by Vnext from the production data."),(0,n.kt)("h2",{id:"example-of-a-dark-launch"},"Example of a dark launch"),(0,n.kt)("p",null,"You can find examples of a dark launch in the ",(0,n.kt)("a",{parentName:"p",href:"/category/demo-project"},"demo project"),"."))}h.isMDXComponent=!0},2785:(e,t,a)=>{a.d(t,{Z:()=>r});const r=a.p+"assets/images/dl-external-dab999c4d407229df39183f961bf6f24.png"},3381:(e,t,a)=>{a.d(t,{Z:()=>r});const r=a.p+"assets/images/dl-internal-c6f0b932237264ef6544293e33c21439.png"},9962:(e,t,a)=>{a.d(t,{Z:()=>r});const r=a.p+"assets/images/dark-launch-basic-1af450db78e248670e12a0d44c81a5e4.png"}}]);